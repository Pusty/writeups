#include "nolibc-syscall-linux.h"

// gcc exploit.c -nostdlib -static -o exploit


// array at 0x24b8
char* names[] = {"crab-", "penguin-", "lemonthink-", "msfrog-", "af-", "dragon-"};

void _start(void) {
    
    // open crab device
    char dev_crab[] = "/dev/crab";
    int fd = open2(dev_crab, O_RDWR);
    if (fd < 0) {
        write_cstring_using_stack(2, "Error: unable to open /dev/crab\n");
        exit(1);
    }

    
    // We need to pass 11 iterations
    for(int loopindex=0;loopindex<11;loopindex++) {
        
        
        // read buffer
        char buffer[256];
        ssize_t rdlen = read_buffer(fd, buffer, sizeof(buffer));
        if(rdlen > 0) {
            if (!write_all(1, buffer, (size_t)rdlen)) {
                write_cstring_using_stack(2, "Error: failed writing to the standard output\n");
                close(fd);
                exit(1);
            }
        }
        
        // UTF-8 Encoding!
        // CRAB    b'\xf0\x9f\xa6\x80'
        // PENGUIN b'\xf0\x9f\x90\xa7'
        // LEMON   b'\xf0\x9f\x8d\x8b'
        // FROG    b'\xf0\x9f\x90\xb8'
        // CAT     b'\xf0\x9f\x90\xb1'
        // DRAGON  b'\xf0\x9f\x90\x89'
        
        
        char solution[256];
        int solutionindex = 0;
        for(int offset=0;offset<10;offset++) {
            int state = 0; // see write_callback (iter) handlers
            if(buffer[offset*4+0] == '\xf0' && buffer[offset*4+1] == '\x9f') {
                if(buffer[offset*4+2] == '\xa6' && buffer[offset*4+3] == '\x80') {
                    state = 0;
                }else if(buffer[offset*4+2] == '\x90' && buffer[offset*4+3] == '\xa7') {
                    state = 1;
                }else if(buffer[offset*4+2] == '\x8d' && buffer[offset*4+3] == '\x8b') {
                    state = 2;
                }else if(buffer[offset*4+2] == '\x90' && buffer[offset*4+3] == '\xb8') {
                    state = 3;
                }else if(buffer[offset*4+2] == '\x90' && buffer[offset*4+3] == '\xb1') {
                    state = 4;
                }else if(buffer[offset*4+2] == '\x90' && buffer[offset*4+3] == '\x89') {
                    state = 5;
                }else {
                    write_cstring_using_stack(2, "Error: Emoji not parsed\n");
                    close(fd);
                    exit(1);
                }
            }else {
                write_cstring_using_stack(2, "Error: No emoji received\n");
                close(fd);
                exit(1);
            }
            
            // current loop  + emoji state mod 6 from array
            char* thisone = names[(loopindex+state)%6];
            for(int i=0;i<nolibc_strlen(thisone);i++) {
                solution[solutionindex+i] = thisone[i];
            }
            solutionindex+=nolibc_strlen(thisone);
            
        }
        // remove last '-'
        solution[solutionindex-1] = 0; 
        solution[solutionindex] = 0;
        
        // echo out for debugging
        write_all(1, solution, solutionindex-1);
        write_cstring_using_stack(1, "\n");
        
        // send to /dev/crab
        write(fd, solution, solutionindex-1);
    }

    // Receive flag
    char flag[256];
    ssize_t flaglen = read_buffer(fd, flag, sizeof(flag));
    if(flaglen > 0) {
        if (!write_all(1, flag, (size_t)flaglen)) {
            write_cstring_using_stack(2, "Error: failed writing to the standard output [flag]\n");
            close(fd);
            exit(1);
        }
    }


    close(fd);
    exit(0);
}